# 들어가기 전에
- 이 포스팅은 https://codeburst.io/the-only-nodejs-introduction-youll-ever-need-d969a47ef219 에 있는 포스팅을 번역한 것입니다. 오역이나 의역이 있을 수 있습니다. 지적해주시면 확인 후 바로 정정하겠습니다.

- original source of this posting is from https://codeburst.io/the-only-nodejs-introduction-youll-ever-need-d969a47ef219 If the original author requests deletion, it will be deleted immediately.

- Translated by Jake Seo (서진규)

	- https://velog.io/@jakeseo_me
	- https://github.com/n00nietzsche

# 시작

> 자바스크립트 환경에서 웹앱을 작성하는 방법에 대해 상세하게 소개합니다.

만일 당신이 프론트엔드 코드를 작성한다면, JS에 매우 의존도가 높기 때문에 노드 JS로 웹앱을 작성하는 것은 매우 쉬운 일일 것입니다.

노드 JS는 만능이 아니라는 것을 이해하는 것은 매우 중요합니다. 모든 프로젝트에서 노드 JS만을 선택하는 것은 능사가 아님을 알아두세요. 누구나 노드 JS로 서버를 만들 수 있지만, 큰 스케일의 웹앱을 작성하기 위해서는 언어에 대한 깊은 수준의 이해가 필요하다는 것을 명심하세요.

그럼 시작합니다.

# Node.js. 이전

웹 어플리케이션은 클라이언트/서버 모델로 작성됐습니다. 클라이언트는 서버로부터 리소스를 요청하고 서버는 리소스를 응답했습니다. 서버는 오직 클라이언트가 요청했을 때만 응답을 했고 각각의 응답이 끝나면 연결을 닫아버렸죠.

이 패턴은 매우 효율적입니다. 왜냐하면 서버로 들어오는 모든 요청은 시간과 리소스(memory, CPU etc)가 들기 때문이죠. 요청된 리소스들에 대한 응답만 한 후에 서버를 닫아버리고 그래서 서버가 다른 요청들에도 응답할 수 있게 만드는 것은 똑똑한 선택이었습니다.

"어떻게 서버는 동시에 수백만의 요청에 이렇게 응답할 수 있었을까요?" 만일 당신이 이렇게 물어본다면, 당신은 이것이 그다지 좋은 방법이 아님을 알고 있는 것입니다. 만일 다른 요청이 전부 응답되기까지 클라이언트가 보내는 서버로의 요청이 딜레이 된다면 말이죠.

당신이 페이스북에 방문했는데 먼저 요청된 수천명의 사람들의 요청 때문에 5분을 기다리란 소리를 들었다는 것을 상상해보세요. 적어도 몇천 최소한 몇백개의 요청이 한번에 들어올 때 처리할 방법이 적어도 하나는 있어야 합니다. 사실 좋은 방법이 있는데, 그것은 `스레드(Threads)`라고 불리는 것입니다.

스레드는 시스템이 다중적인 명령을 동시에 수행하는 것을 가능하게 해줍니다. 모든 요청은 새로운 스레드를 열게 됩니다. 모든 스레드는 코드실행을 완수하기 위해 필요한 모든 것을 가지고 있습니다.

뭔가 이상하게 들린다구요? 이러한 비유를 사용해봅시다.

> 한 사람만 음식을 서빙하는 레스토랑을 상상해보세요. 음식을 주문하는 사람이 엄청나게 많다면 그 레스토랑은 정신이 하나도 없이 미쳐돌아갈 것입니다. 사람들은 대기중인 주문에 대한 서빙이 모두 끝날 때까지 기다려야 할 것입니다. 이 문제를 해결하는 유일한 방법은 음식을 서빙할 종업원을 더 구하는 것이겠죠? 이러한 방법으로, 한번에 더 많은 손님들이 음식을 받을 수 있을 것입니다.

개개의 스레드는 새로운 직원입니다. 그리고 브라우저는 배고픈 사람들입니다. 이젠 이해가 되겠죠?

하지만 이러한 체계는 안 좋은 점이 있습니다. 결국 어느 순간에는 엄청나게 많은 요청들이 들어오고 새로운 스레드들이 시작될 것이고 이러한 작업은 시스템 내의 모든 메모리와 리소스를 소비할 것입니다. 아까 식당 얘기로 돌아가보면, 더 많은 직원을 고용하려면 더 많은 돈과 공간이 필요하죠.

하지만 서버가 즉시 브라우저에 응답할 수 있는 것은 여전히 엄청난 장점 중 하나입니다. 클라이언트와의 연결이 닫히는 순간에는 메모리와 같은 리소스도 다시 돌아오겠죠.

이 시스템의 장점은 CPU 집약적(intensive) 어플리케이션에 뛰어나다는 겁니다. CPU 집약적(intensive) 명령어들은 많은 로직과 컴퓨팅할 시간을 필요로 합니다. 모든 새로운 요청이 새로운 스레드들에 의해 처리되면, 메인 스레드는 매우 큰 작업들로부터 벗어나게 됩니다. 그로 인해 메인 스레드는 시스템을 빠르게 만들고 중대한 연산을 할 수 있게 됩니다.

메인 스레드와 동떨어져 코드들이 실행되기 때문에 꽤 효율적이어보이지 않나요? 과연 이것보다 더 좋은 시스템이 있을까요?

# Node.js 등장
우리가 루비 온 레일즈에서 돌아가는 멀티 스레드 지원 서버를 가지고 있다고 상상해봅시다. 그 서버는 서버에서 파일을 읽습니다. 그리고 요청한 브라우저에 전송합니다. 루비는 파일을 읽고 내용을 반환하기 위해 `파일 시스템(file system)`에게 요청을 전달할 것입니다. 파일 시스템은 컴퓨터에 데이터를 저장하고 불러오는데 사용됩니다.

요점은 루비가 파일 시스템의 작업이 끝날 때까지 아무것도 안한다는 것입니다. 그리곤 루비는 내용을 수집하고 그 내용을 브라우저로 보냅니다.

여기가 노드 js가 등장하는 곳입니다. 노드 js에서는 파일 시스템이 파일을 읽는 동안 노드는 남는 시간을 다른 요청을 처리하는데 사용합니다. 파일 시스템의 작업이 끝나게 되면, 파일 시스템은 노드에게 리소스를 가져가서 브라우저에게 뿌리라고 합니다. 이것은 노드 js의 `event loop` 때문에 가능한 일입니다.

> 노드 js는 자바스크립트와 이벤트 루프로 만들어졌습니다.

![nodejs-architecture.png](https://images.velog.io/post-images/jakeseo_me/f91dc1f0-57a8-11e9-8ae5-8fb184badb72/nodejs-architecture.png)

> image source is from https://codeburst.io/the-only-nodejs-introduction-youll-ever-need-d969a47ef219

이벤트 루프는 말하자면 이벤트를 기다렸다가 전송해주는 프로그램입니다. 다른 중요한 사실 하나는 **자바스크립트는 싱글스레드라는 것입니다. 노드도 그렇습니다.**

우리가 식당으로 예를 들었던 게 기억나나요? 노드는 몇명의 손님이 있냐에 상관 없이 1명의 종업원만 있는 겁니다.

각각 요청에 각 1개의 스레드를 요구하는 다른 언어들과는 다르게 노드는 모든 요청을 받고 난 후에 대부분의 작업을 다른 시스템 워커들에게 부여합니다. OS커널로부터 도움을 받아 이런 일들을 효율적으로 처리하는 `Libuv`라고 불리는 라이브러리가 있습니다. 백그라운드 워커들이 작업을 완료했을 때, 해당 이벤트로 등록된 노드JS 콜백에 이벤트를 전달합니다. 

여기서 `콜백(callbacks)`이란 개념이 소개되었습니다. 콜백은 다른 함수에 인자로 던져지는 녀석들입니다. 특정한 조건이 충족됐을 때 호출됩니다.

노드 js 개발자들이 일반적으로 하는 일은 특정한 노드 이벤트가 발생했을 때 불러지는 이벤트 핸들러를 작성하는 것입니다.
